import streamlit as st
from series import SeriesVisualizer
import plotly.express as px
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from ceic_api_client.pyceic import Ceic
import os
import json
import sys
import re # Import regex for ID validation


#CONSTANTS
JSON_FILES = ["geo_data.json", "frequencies_data.json", "statuses_data.json"]

#Streamlit page configuration
st.set_page_config(page_title="CEIC Series Data Visualizer", layout="wide")
st.markdown(
        """
        <style>
        .stApp { background-color: #E6E6FA; min-height: 100vh; }
        .stApp > header { background-color: transparent; }
        </style>
        """,
        unsafe_allow_html=True
    )

def initialize_session_state():
    if 'logged_in' not in st.session_state:
        st.session_state.logged_in = False
    if 'ceic_client' not in st.session_state:
        st.session_state.ceic_client = None
    # This will store the ID that was selected in the dropdown or loaded directly
    if 'series_id_for_viz' not in st.session_state:
         st.session_state.series_id_for_viz = None
    if 'series_options' not in st.session_state:
        # This stores the options generated by the search or direct load
        st.session_state.series_options = {}
    # Add state for the selected key in the dropdown
    if 'selected_series_key' not in st.session_state:
        st.session_state.selected_series_key = None


# Helper function to load JSON data safely
def load_json_data(json_file):
    try:
        with open(json_file, "r", encoding="utf-8") as file:
            data = json.load(file)
        return data
    except FileNotFoundError:
        st.error(f"Error: Required file '{json_file}' not found.")
        # You might want to stop the app here if crucial files are missing
        st.stop()
        return None # Return None if file not found
    except json.JSONDecodeError:
        st.error(f"Error: Could not decode JSON from '{json_file}'. Please check the file content.")
        st.stop()
        return None # Return None if JSON is invalid
    except Exception as e:
        st.error(f"An unexpected error occurred loading '{json_file}': {e}")
        st.stop()
        return None # Return None for other errors

def load_json_dropdown(json_files):
    selected_values = {}
    for json_file in json_files:
        data = load_json_data(json_file) # Use the helper function

        if not data:
             st.warning(f"No options found or loaded from {json_file}")
             selected_values[json_file] = None
             continue # Skip to the next file

        # Filter just countries to avoid fetching wrong ids in geo response
        if json_file == "geo_data.json":
            # Ensure data is a list before filtering
            if isinstance(data, list):
                data = [item for item in data if item.get("type") == "COUNTRY"]
            else:
                 st.warning(f"Unexpected data format in {json_file}")
                 selected_values[json_file] = None
                 continue


        # Ensure data is a list and has at least one item before accessing index 0
        if not isinstance(data, list) or not data:
             st.warning(f"No valid options found in {json_file}")
             selected_values[json_file] = None
             continue

        # key is "name" or "title" in case of the  geo_data
        # Ensure the required keys exist in the first item
        first_item = data[0]
        key_name = None
        if "name" in first_item:
            key_name = "name"
        elif "title" in first_item:
            key_name = "title"
        else:
             st.warning(f"Could not find 'name' or 'title' key in the first item of {json_file}")
             selected_values[json_file] = None
             continue

        if "id" not in first_item:
            st.warning(f"Could not find 'id' key in the first item of {json_file}")
            selected_values[json_file] = None
            continue


        options = {item[key_name]: item["id"] for item in data if key_name in item and "id" in item}

        # Ensure options dictionary is not empty after processing
        if not options:
             st.warning(f"Failed to extract valid options from {json_file}")
             selected_values[json_file] = None
             continue

        # Dropdown options
        # Use a unique key for each selectbox based on the filename
        selectbox_key = f"selectbox_{json_file.replace('_data.json', '')}"
        # Use options.keys() directly, Streamlit handles the first item as default if no state key
        selected_option = st.selectbox(f"Select {json_file.replace('_data.json', '').capitalize()}:", list(options.keys()), key=selectbox_key)
        selected_values[json_file] = options[selected_option]


    return selected_values

def load_series_by_id(series_id_str):
    """Attempts to load a single series by ID and populate series_options."""
    if not series_id_str:
        st.warning("Please enter a Series ID to load.")
        st.session_state.series_options = {}
        st.session_state.series_id_for_viz = None
        st.session_state.selected_series_key = None
        return

    # Basic validation: Check if it looks like a number (or starts with SR)
    if not re.match(r'^[0-9]+$', series_id_str) and not series_id_str.startswith('SR'):
         st.warning(f"Invalid Series ID format: '{series_id_str}'. Please enter a numeric ID or an SR code.")
         st.session_state.series_options = {}
         st.session_state.series_id_for_viz = None
         st.session_state.selected_series_key = None
         return


    ceic_client = st.session_state.ceic_client
    if not ceic_client:
        st.error("CEIC client not initialized.")
        return

    # Attempt to fetch metadata for the ID to confirm it's valid and get a name
    with st.spinner(f"Loading Series ID {series_id_str}..."):
        try:
            # Using series_metadata to get confirmation and a name
            result = ceic_client.series_metadata(series_id=series_id_str)

            if result and hasattr(result, 'data') and result.data:
                 # Assuming result.data is a list and the first item is the series
                series_info = result.data[0] # Metadata endpoint returns a list of items

                # Check if series_info has the expected metadata structure
                if hasattr(series_info, 'metadata') and hasattr(series_info.metadata, 'id'):
                    series_id = series_info.metadata.id # Use the ID returned by the API
                    name = getattr(series_info.metadata, 'name', 'Unnamed Series') # Get name if available

                    # Populate series_options with just this series
                    label = f"{name} (ID: {series_id})"
                    st.session_state.series_options = {label: series_id}

                    # Set the series ID for visualization and the selected key
                    st.session_state.series_id_for_viz = series_id
                    st.session_state.selected_series_key = label
                    st.success(f"Successfully loaded Series ID {series_id}.")
                else:
                     st.error(f"Could not retrieve metadata for Series ID {series_id_str}. Please check the ID.")
                     st.session_state.series_options = {}
                     st.session_state.series_id_for_viz = None
                     st.session_state.selected_series_key = None

            else:
                st.error(f"Series ID {series_id_str} not found or accessible.")
                st.session_state.series_options = {}
                st.session_state.series_id_for_viz = None
                st.session_state.selected_series_key = None

        except Exception as e:
            st.error(f"An error occurred loading Series ID {series_id_str}: {e}")
            st.session_state.series_options = {}
            st.session_state.series_id_for_viz = None
            st.session_state.selected_series_key = None


def search_series(keyword, dropdown):
    """Performs a keyword search with filters and populates series_options."""
    ceic_client = st.session_state.ceic_client

    if not ceic_client:
        st.error("CEIC client not initialized.")
        return

    if not keyword:
        st.warning("Please enter a keyword to search.")
        st.session_state.series_options = {}
        st.session_state.series_id_for_viz = None
        st.session_state.selected_series_key = None
        return

    # Ensure dropdown values are selected before searching
    # These are required filters for the keyword search based on your previous logic
    frequency_id = dropdown.get("frequencies_data.json")
    geo_id = dropdown.get("geo_data.json")
    status_id = dropdown.get("statuses_data.json")

    if frequency_id is None or geo_id is None or status_id is None:
         st.warning("Please ensure Frequency, Geo, and Status are selected for keyword search.")
         st.session_state.series_options = {}
         st.session_state.series_id_for_viz = None
         st.session_state.selected_series_key = None
         return

    search_params = {
        "keyword": keyword,
        "frequency": [frequency_id], # Pass as list
        "geo": [geo_id],           # Pass as list
        "status": [status_id],       # Pass as list
        "with_vintage_enabled_only": "TRUE"
    }

    # Clear previous options before performing a new search
    st.session_state.series_options = {}
    st.session_state.series_id_for_viz = None
    st.session_state.selected_series_key = None

    with st.spinner(f"Searching for '{keyword}' with filters..."):
        try:
            # The search method returns an iterable, so we need to consume it
            search_results_list = list(ceic_client.search(**search_params))
            series_options = {}

            if search_results_list:
                # Search through all the results pages
                for result_page in search_results_list:
                    if hasattr(result_page, 'data') and hasattr(result_page.data, 'items'):
                        for series in result_page.data.items:
                            # Ensure series, metadata, name, and id exist
                            if hasattr(series, 'metadata') and hasattr(series.metadata, 'name') and hasattr(series.metadata, 'id'):
                                name = series.metadata.name
                                series_id = series.metadata.id
                                label = f"{name} (ID: {series_id})"
                                series_options[label] = series_id


                # Updates the session_state
                if series_options:
                    st.session_state.series_options = series_options
                    # Set the first option as the default selected series ID for visualization
                    first_key = list(series_options.keys())[0]
                    st.session_state.series_id_for_viz = series_options[first_key]
                    # Also set the selected_series_key for the selectbox
                    st.session_state.selected_series_key = first_key
                    st.info(f"Found {len(series_options)} series.")

                else:
                    st.error("No results found for the given criteria.")
                    st.session_state.series_options = {} # Clear previous results if any
                    st.session_state.series_id_for_viz = None
                    st.session_state.selected_series_key = None


            else:
                st.error("Search returned no results.")
                st.session_state.series_options = {} # Clear previous results
                st.session_state.series_id_for_viz = None
                st.session_state.selected_series_key = None


        except Exception as e:
            st.error(f"An error occurred during search: {e}")
            # print(f"Traceback: {sys.exc_info()[2]}") # Optional: print traceback for debugging
            st.session_state.series_options = {} # Clear previous results
            st.session_state.series_id_for_viz = None
            st.session_state.selected_series_key = None


def display_series_selection():
    """Displays the dropdown to select a series from loaded options."""
    if st.session_state.series_options:
        st.subheader("Select Series")
        options_keys = list(st.session_state.series_options.keys())

        # Determine the default index based on the selected_series_key state
        default_index = 0
        if st.session_state.selected_series_key in options_keys:
            default_index = options_keys.index(st.session_state.selected_series_key)
        elif options_keys:
            # If the previous selection isn't in the new list, default to the first item
            st.session_state.selected_series_key = options_keys[0]
            st.session_state.series_id_for_viz = st.session_state.series_options[st.session_state.selected_series_key]


        # Use a unique key for the selectbox to persist selection
        selected_key = st.selectbox(
            "Choose a series:",
            options=options_keys,
            index=default_index,
            key='series_selection_dropdown'
        )

        # Update the series_id_for_viz based on the current selection
        st.session_state.series_id_for_viz = st.session_state.series_options[selected_key]
        st.session_state.selected_series_key = selected_key # Update the key state


    else:
        # This is displayed when series_options is empty
        st.info("Load a series by ID or perform a search to see options here.")
        st.session_state.series_id_for_viz = None # Ensure series_id_for_viz is None if no options
        st.session_state.selected_series_key = None



def display_visualizations():

    # Use the client from session state
    ceic_client = st.session_state.ceic_client

    if not ceic_client:
        st.error("CEIC client not initialized.")
        return

    # Use the series_id_for_viz which should be set by the selection/load logic
    series_id_to_visualize = st.session_state.series_id_for_viz

    if series_id_to_visualize is None:
        # This case should ideally be prevented by button disabled state
        st.error("No series selected or loaded. Please load a series first.")
        return

    # Pass the client object and the determined series ID to the Visualizer
    visualizer = SeriesVisualizer(ceic_client, series_id_to_visualize)
    st.subheader(f"Visualizing Series ID: {series_id_to_visualize}")

    # Fetch data using threading
    with st.spinner(f"Fetching data for Series ID {series_id_to_visualize}..."):
        visualizer.fetch_all_data()

    # Check for errors during fetching
    if visualizer.metadata is None:
         st.error(f"Failed to fetch metadata for Series ID {series_id_to_visualize}. Please check the ID and your subscription access.")
         return # Cannot proceed without metadata and potentially other data0

    # Check if other data was fetched
    data_fetched = visualizer.series_data is not None
    vintages_fetched = visualizer.df_reversed is not None

    if not data_fetched and not vintages_fetched:
         st.warning(f"No time series data (latest revisions) or vintages data could be fetched for Series ID {series_id_to_visualize}. Metadata was loaded.")
         return # Cannot display anything else

    # --- Display Visualizations based on available data ---

    # Time series data 
    if data_fetched:
        st.subheader("Time Series Data")
        df_series = visualizer.process_series_data()
        if df_series is not None and not df_series.empty:
            try:
                fig = visualizer.plot_series(df_series)
                if fig:
                    st.plotly_chart(fig)
                else:
                    st.error("Failed to generate series plot.") # Should not happen if df is valid
            except Exception as e:
                 st.error(f"Error plotting series data: {e}")
                 # print(f"Traceback plotting series: {sys.exc_info()[2]}") # Debugging
        elif df_series is not None and df_series.empty:
             st.info("No time series data points found for this series.")
        else:
            st.error("Failed to process series data.") # Should not happen if series_data is valid

    else:
        st.info("Time series data (latest revisions) not available for this series.")
    
    st.markdown("<br><br>", unsafe_allow_html=True)

    # Vintages related visualizations (require vintages_data)
    if vintages_fetched:
        # Vintages Table
        st.subheader("Vintages Table with Highlights")
        df_styled = visualizer.style_vintages_table()
        if df_styled is not None:
             st.dataframe(df_styled)
        else:
             st.error("Failed to style vintages table.") # Should not happen if df_reversed is valid
        
        st.markdown("<br><br>", unsafe_allow_html=True)

        # Vintages Heatmap
        st.subheader("Heatmap of Vintage Changes")
        try:
            fig_heatmap = visualizer.plot_vintages_heatmap()
            if fig_heatmap:
                st.pyplot(fig_heatmap)
            else:
                 st.error("Failed to generate vintages heatmap.") # Should not happen if df_reversed is valid
        except Exception as e:
             st.error(f"Error plotting heatmap: {e}")
        
        st.markdown("<br><br>", unsafe_allow_html=True)

        # Animated Timeseries Vintages
        st.subheader("Animated Timeseries Vintages")
        try:
            fig_animated = visualizer.plot_animated_vintages()
            if fig_animated:
                st.plotly_chart(fig_animated)
            else:
                 st.error("Failed to generate animated vintages plot.") # Should not happen if df_reversed is valid
        except Exception as e:
             st.error(f"Error plotting animated vintages: {e}")
        
        st.markdown("<br><br>", unsafe_allow_html=True)

        # Vintage comparison Between dates
        st.subheader("Vintage Comparison Between Two Dates")
        try:
            fig_comparison = visualizer.plot_vintage_comparison()
            if fig_comparison:
                st.plotly_chart(fig_comparison)
            else:
                 st.error("Failed to generate vintage comparison plot.") # Should not happen if df_reversed is valid
        except Exception as e:
             st.error(f"Error plotting vintage comparison: {e}")
        
        st.markdown("<br><br>", unsafe_allow_html=True)

        # Difference between first and last
        st.subheader("Difference Between Last and First Available Values per Vintage")
        try:
            fig_bar = visualizer.plot_vintage_differences()
            if fig_bar:
                st.pyplot(fig_bar)
            else:
                 st.error("Failed to generate vintage differences plot.") # Should not happen if df_reversed is valid
        except Exception as e:
             st.error(f"Error plotting vintage differences: {e}")

    else:
        st.info("Vintages data not available for this series.")

    # Important: Manually close matplotlib figures after st.pyplot
    plt.close('all')


def login_page():

    col1, col2, col3 = st.columns([2, 1, 2])

    with col2:
        st.image("ceic.webp", width=250)
    
    col1, col2, col3 = st.columns([1, 1, 1])

    with col2:
        st.title("Data Visualizer Login")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")

        if st.button("Login"):
            if not username or not password:
                st.warning("Please enter both username and password.")
                return

            with st.spinner("Logging in..."):
                try:
                    # Attempt to login to CEIC
                    # Set server URL first if not already set globally by pyceic
                    # Ceic.set_server("https://api.ceicdata.com/v2") # Assuming default is fine or set elsewhere
                    client = Ceic.login(username, password)
                    st.session_state.ceic_client = client
                    st.session_state.logged_in = True
                    st.success("Login successful!")
                    # Rerun to switch to the main app view
                    st.rerun()
                except Exception as e:
                    st.error(f"Login failed: {e}. Please check your credentials and API server configuration.")
                    st.session_state.logged_in = False
                    st.session_state.ceic_client = None


def main_app():
    # Title
    st.title("CEIC Series Data Visualizer")

    # Sidebar
    with st.sidebar:
        st.image("ceic.webp", width=250)
        st.title("Data Loading Options")

        # --- Direct Series ID Input ---
        st.subheader("Load by Series ID")
        direct_series_id_input = st.text_input("Enter Series ID", key="direct_id_input_sidebar").strip()
        # Button to trigger loading by ID
        load_id_button = st.button("Load", disabled=not direct_series_id_input)

        st.markdown("---") # Separator

        # --- Keyword Search Filters ---
        st.subheader("Search by Filters")
        keyword = st.text_input("Keyword for Search", key="keyword_input_sidebar")
        dropdown = load_json_dropdown(JSON_FILES) # Make sure JSON files exist and are loaded

        # Determine if keyword search filters are valid (keyword is required)
        dropdown_valid = all(value is not None for value in dropdown.values())
        search_button_disabled = not (keyword and dropdown_valid)
        search_button = st.button("Search", disabled=search_button_disabled)


    # --- Logic triggered by sidebar buttons ---

    # If Load Series by ID button is clicked
    if load_id_button:
        # Call the function to load the series by ID and update state
        load_series_by_id(direct_series_id_input)

    # If Search Series by Filters button is clicked
    if search_button:
        # Call the search function and update state
        search_series(keyword, dropdown)

    # --- Series Selection Dropdown (always visible if options exist) ---
    display_series_selection()

    # --- Load Data Button (uses the ID from st.session_state.series_id_for_viz) ---
    load_data_disabled = not st.session_state.series_id_for_viz
    load_data_button = st.button("Load Data", disabled=load_data_disabled)

    # --- Logic triggered by Load Data button click ---
    if load_data_button:
        # display_visualizations reads from st.session_state.series_id_for_viz
        display_visualizations()


def main():
    
    initialize_session_state()

    if st.session_state.logged_in:
        # Ensure the CEIC server is set before making any API calls
        Ceic.set_server("https://api.ceicdata.com/v2") # Set the server URL once after login/initialization
        main_app()
    else:
        login_page()


if __name__ == '__main__':
    main()